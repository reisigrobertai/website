<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Starmap Background</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.43/moment-timezone-with-data.min.js"></script>
    
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body { 
            overflow: hidden; 
            background: #000000;
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
            pointer-events: none;
        }
        
        #loading { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 20px; 
            color: #FFD700; 
            text-align: center; 
            font-family: Arial, sans-serif;
        }
        
        .loading-spinner { 
            width: 60px; 
            height: 60px; 
            margin: 0 auto 30px; 
            border: 4px solid rgba(255,215,0,0.2); 
            border-top-color: #FFD700; 
            border-radius: 50%; 
            animation: spin 1.5s linear infinite; 
        }
        
        @keyframes spin { 
            to { transform: rotate(360deg); } 
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="loading">
            <div class="loading-spinner"></div>
            Loading celestial data...
        </div>
    </div>
    
    <script>
        // Configuration
        const BACKEND_URL = 'https://backend.astro.reisig.org';
        const LOCATION = { lat: 51.198062, lon: 6.692754 }; // Default location (you can change this)
        const SETTINGS = {
            magCutoff: 7.5,     // Visibility 10 -> 7.5 actual
            starScale: 0.06,    // Radiance 0.6 -> 0.06 actual  
            brightness: 2.0,    // Brightness 10 -> 2.0 actual
            glowIntensity: 0.47, // Aura 4.7 -> 0.47 actual
            colorTemp: 0.4,     // Temperature 2.0 -> 0.4 actual
            twinkle: true
        };
        const ROTATION_SPEED = 12 / 60; // 12 degrees per minute = 0.2 degrees per second
        const INITIAL_POLAR_ANGLE = Math.PI / 4; // 45 degrees looking up

        let scene, camera, renderer;
        let starsMesh, horizonMesh, earthMesh, sunGlowMesh;
        let animationTime = 0;
        let rotationAngle = 0;

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.1);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            createEarthAndHorizon();
            document.getElementById('loading')?.remove();
        }

        function createEarthAndHorizon() {
            // Earth sphere
            const earthGeometry = new THREE.SphereGeometry(99, 64, 32);
            const earthMaterial = new THREE.ShaderMaterial({
                uniforms: { 
                    time: { value: 0 }, 
                    shininess: { value: 0.8 } 
                },
                vertexShader: `
                    varying vec3 vPosition; 
                    varying vec3 vNormal; 
                    void main(){ 
                        vPosition=position; 
                        vNormal=normalize(normalMatrix*normal); 
                        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); 
                    }`,
                fragmentShader: `
                    uniform float time; 
                    uniform float shininess; 
                    varying vec3 vPosition; 
                    varying vec3 vNormal; 
                    void main(){ 
                        float h=(vPosition.y+99.0)/100.0; 
                        vec3 c1=vec3(0.0,0.02,0.08); 
                        vec3 c2=vec3(0.02,0.04,0.1); 
                        vec3 c3=vec3(0.01,0.01,0.03); 
                        vec3 color=mix(c1,c2,h); 
                        color=mix(color,c3,sin(time*0.5+vPosition.x*0.05)*0.3+0.5); 
                        float sh=0.02*sin(time*2.0+vPosition.x*0.1+vPosition.z*0.1); 
                        color+=sh; 
                        vec3 lightDir=normalize(vec3(sin(time*0.3),0.7,cos(time*0.3))); 
                        float diff=max(dot(vNormal,lightDir),0.0); 
                        vec3 viewDir=normalize(-vPosition); 
                        vec3 reflectDir=reflect(-lightDir,vNormal); 
                        float spec=pow(max(dot(viewDir,reflectDir),0.0),32.0); 
                        color+=vec3(0.05,0.08,0.15)*diff*shininess; 
                        color+=vec3(0.1,0.15,0.3)*spec*shininess*0.5; 
                        gl_FragColor=vec4(color,1.0); 
                    }`,
                transparent: false, 
                depthWrite: true, 
                depthTest: true
            });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            earthMesh.position.y = -99.5;
            earthMesh.renderOrder = -1;
            scene.add(earthMesh);

            // Horizon ring
            const horizonGeometry = new THREE.RingGeometry(98, 100, 128);
            const horizonMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4682B4, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.4 
            });
            horizonMesh = new THREE.Mesh(horizonGeometry, horizonMaterial);
            horizonMesh.rotation.x = Math.PI / 2;
            horizonMesh.renderOrder = 0;
            scene.add(horizonMesh);

            // Sun glow
            const sunGlowGeometry = new THREE.RingGeometry(95, 105, 128);
            const sunGlowMaterial = new THREE.ShaderMaterial({
                uniforms: { 
                    time: { value: 0 } 
                },
                vertexShader: `
                    varying vec2 vUv; 
                    void main(){ 
                        vUv=uv; 
                        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); 
                    }`,
                fragmentShader: `
                    uniform float time; 
                    varying vec2 vUv; 
                    void main(){ 
                        float d=distance(vUv,vec2(0.5)); 
                        float it=0.15+0.08*sin(time*0.5); 
                        float a=it*(1.0-smoothstep(0.45,0.55,d)); 
                        vec3 col=mix(vec3(0.5,0.7,1.0), vec3(0.8,0.6,1.0), sin(time*0.3)*0.5+0.5); 
                        gl_FragColor=vec4(col,a); 
                    }`,
                transparent: true, 
                blending: THREE.AdditiveBlending, 
                side: THREE.DoubleSide, 
                depthWrite: false
            });
            sunGlowMesh = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            sunGlowMesh.rotation.x = Math.PI / 2;
            sunGlowMesh.position.y = 0.1;
            sunGlowMesh.renderOrder = 1;
            scene.add(sunGlowMesh);
        }

        function horizontalToCartesian(altitude, azimuth, radius = 100) {
            const altRad = altitude * Math.PI / 180;
            const azRad = (90 - azimuth) * Math.PI / 180;
            return { 
                x: radius * Math.cos(altRad) * Math.cos(azRad), 
                y: radius * Math.sin(altRad), 
                z: -radius * Math.cos(altRad) * Math.sin(azRad) 
            };
        }

        function bvToColor(bv, tempScale) {
            if (bv === null || bv === undefined || tempScale === 0) return new THREE.Color(1, 1, 1);
            bv = Math.max(-0.4, Math.min(2.0, bv)) * tempScale;
            let r, g, b;
            if (bv < 0.0) { 
                r = 0.6 + bv * 0.7; 
                g = 0.7 + bv * 0.5; 
                b = 1.0; 
            } else if (bv < 0.4) { 
                r = 0.85 + bv * 0.375; 
                g = 0.85 + bv * 0.125; 
                b = 1.0 - bv * 0.875; 
            } else if (bv < 1.6) { 
                r = 1.0; 
                g = 0.9 - (bv - 0.4) * 0.5; 
                b = 0.8 - (bv - 0.4) * 0.5; 
            } else { 
                r = 1.0; 
                g = 0.4 - (bv - 1.6) * 0.25; 
                b = 0.3 - (bv - 1.6) * 0.25; 
            }
            return new THREE.Color(r, g, b);
        }

        async function createStarField() {
            const now = moment();
            const dateStr = now.format('YYYY-MM-DD');
            const timeStr = now.format('HH:mm');
            const timezone = moment.tz.guess();

            try {
                const response = await fetch(
                    `${BACKEND_URL}/stars?lat=${LOCATION.lat}&lon=${LOCATION.lon}&date=${dateStr}&time=${timeStr}&tz=${timezone}&magCutoff=${SETTINGS.magCutoff}&starScale=${SETTINGS.starScale}&brightness=${SETTINGS.brightness}&glowIntensity=${SETTINGS.glowIntensity}&colorTemp=${SETTINGS.colorTemp}`
                );
                const starData = await response.json();

                if (starsMesh) { 
                    scene.remove(starsMesh); 
                    starsMesh.geometry.dispose(); 
                    starsMesh.material.dispose(); 
                }

                const positions = [], colors = [], sizes = [], twinklePhases = [];
                starData.forEach(({ pos, color, size, twinklePhase }) => {
                    positions.push(pos.x, pos.y, pos.z);
                    colors.push(...color);
                    sizes.push(size);
                    twinklePhases.push(twinklePhase);
                });

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                geometry.setAttribute('twinklePhase', new THREE.Float32BufferAttribute(twinklePhases, 1));
                
                const starTexture = createStarTexture(SETTINGS.glowIntensity);
                const material = new THREE.ShaderMaterial({
                    uniforms: { 
                        pointTexture: { value: starTexture }, 
                        brightness: { value: SETTINGS.brightness }, 
                        time: { value: 0 }, 
                        twinkleEnabled: { value: SETTINGS.twinkle ? 1.0 : 0.0 } 
                    },
                    vertexShader: `
                        attribute float size; 
                        attribute float twinklePhase; 
                        varying vec3 vColor; 
                        uniform float time; 
                        uniform float twinkleEnabled; 
                        void main(){ 
                            vColor=color; 
                            float t=1.0; 
                            if (twinkleEnabled>0.5){ 
                                t=0.85+0.15*sin(time*0.8+twinklePhase); 
                                if(size<1.2){ 
                                    t*=0.9+0.1*sin(time*1.2+twinklePhase*1.5); 
                                } 
                            } 
                            vec4 mvPosition=modelViewMatrix*vec4(position,1.0); 
                            gl_PointSize=size*t*400.0/length(mvPosition.xyz); 
                            gl_Position=projectionMatrix*mvPosition; 
                        }`,
                    fragmentShader: `
                        uniform sampler2D pointTexture; 
                        uniform float brightness; 
                        varying vec3 vColor; 
                        void main(){ 
                            vec4 tex=texture2D(pointTexture, gl_PointCoord); 
                            gl_FragColor=vec4(vColor*brightness,1.0)*tex; 
                        }`,
                    blending: THREE.AdditiveBlending, 
                    depthTest: true, 
                    depthWrite: false, 
                    transparent: true, 
                    vertexColors: true
                });
                
                starsMesh = new THREE.Points(geometry, material);
                starsMesh.renderOrder = 2;
                scene.add(starsMesh);
            } catch (error) {
                console.error('Error fetching star data:', error);
            }
        }

        function createStarTexture(glowIntensity) {
            const canvas = document.createElement('canvas');
            const size = 256;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const c = size / 2;
            const gi = Math.max(0.3, glowIntensity);
            const g = ctx.createRadialGradient(c, c, 0, c, c, c);
            g.addColorStop(0.0, 'rgba(255,255,255,1)');
            g.addColorStop(0.12, 'rgba(255,255,255,0.9)');
            g.addColorStop(0.32, `rgba(255,255,255,${0.45 * gi})`);
            g.addColorStop(0.62, `rgba(255,255,255,${0.18 * gi})`);
            g.addColorStop(1.0, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }

        function updateCamera(deltaTime) {
            // Update rotation angle (degrees per second)
            rotationAngle += ROTATION_SPEED * deltaTime;
            
            // Convert to radians
            const azimuthalAngle = rotationAngle * Math.PI / 180;
            const polarAngle = INITIAL_POLAR_ANGLE;
            
            // Calculate camera look direction
            const radius = 1;
            const x = radius * Math.sin(polarAngle) * Math.cos(azimuthalAngle);
            const y = radius * Math.cos(polarAngle);
            const z = radius * Math.sin(polarAngle) * Math.sin(azimuthalAngle);
            
            // Set camera to look in that direction
            camera.lookAt(x, y, z);
        }

        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Calculate delta time in seconds
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            animationTime += 0.008;
            
            // Update shader uniforms
            if (starsMesh?.material.uniforms.time) {
                starsMesh.material.uniforms.time.value = animationTime;
            }
            if (sunGlowMesh?.material.uniforms.time) {
                sunGlowMesh.material.uniforms.time.value = animationTime;
            }
            if (earthMesh?.material.uniforms.time) {
                earthMesh.material.uniforms.time.value = animationTime;
            }
            if (earthMesh?.material.uniforms.shininess) {
                earthMesh.material.uniforms.shininess.value = 0.8 + 0.2 * Math.sin(animationTime * 0.5);
            }
            
            // Update camera rotation
            updateCamera(deltaTime);
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('load', () => {
            initScene();
            createStarField();
            animate(0);
        });
    </script>
</body>
</html>
